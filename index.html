<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CODE NODES</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Consolas&display=swap');

        :root {
            --bg-dark: #1a1d21;
            --node-bg: #2a2c30;
            --border-color: #4f5255;
            --text-light: #e1e1e3;
            --text-dark: #8f9295;
            --accent-green: #4ade80; /* Tailwind green-400 */
            --accent-green-hover: #22c55e; /* Tailwind green-500 */
            --accent-red: #f43f5e; /* Tailwind rose-500 */
            --accent-orange: #f97316; /* Tailwind orange-500 */
            --accent-orange-hover: #ea580c; /* Tailwind orange-600 */
            --accent-cyan: #22d3ee; /* Tailwind cyan-400 */
            --accent-cyan-hover: #06b6d4; /* Tailwind cyan-500 */
        }

        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            background-color: var(--bg-dark);
            color: var(--text-light);
            overflow: hidden;
            user-select: none;
        }
        #graph-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden; 
            background-image: radial-gradient(var(--border-color) 1px, transparent 1px);
            background-size: 25px 25px;
            cursor: grab;
        }
        #graph-container:active { cursor: grabbing; }
        #world-container { width: 100%; height: 100%; position: relative; transform-origin: 0 0; }
        .node {
            position: absolute;
            background-color: var(--node-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            cursor: grab;
            min-width: 240px;
            min-height: 180px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
            transition: box-shadow 0.2s, border-color 0.2s;
            resize: both;
            overflow: auto;
        }
        .node:active { cursor: grabbing; border-color: var(--accent-green); box-shadow: 0 0 15px rgba(74, 222, 128, 0.3); }
        .node-header { font-weight: bold; padding-bottom: 5px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; color: var(--text-light); }
        .node-params { padding: 8px 0; display: flex; flex-direction: column; gap: 8px; font-size: 0.9em; }
        .param-row { display: flex; justify-content: space-between; align-items: center; position: relative; }
        .param-row.has-key-port {
            padding-left: 15px;
        }
        .param-row label { color: var(--text-dark); }

        /* Toggle Switch */
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--border-color); transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent-green); }
        input:checked + .slider:before { transform: translateX(26px); }

        /* Number/Text Input */
        .param-input { background-color: #1f2124; border: 1px solid var(--border-color); color: var(--text-light); border-radius: 4px; padding: 4px 8px; width: 100%; }
        .param-input:disabled { background-color: #333; color: var(--text-dark); cursor: not-allowed; }
        .node-text { width: 100%; min-height: 80px; border: 1px solid var(--border-color); border-radius: 4px; padding: 8px; resize: vertical; box-sizing: border-box; font-family: 'Consolas', 'Courier New', Courier, monospace; background-color: #1f2124; color: var(--text-light); word-break: break-all; }
        .node-text:focus { outline: none; border-color: var(--accent-green); }
        .node-text[readonly] { background-color: #242629; color: var(--text-dark); }
        
        .io-ports-container { display:flex; justify-content: space-between; }
        .input-ports, .output-ports { display: flex; flex-direction: column; gap: 10px; align-items: center; justify-content: center; position:relative; }
        .node-port { width: 16px; height: 16px; background-color: var(--border-color); border: 2px solid var(--node-bg); border-radius: 50%; cursor: crosshair; box-shadow: none; transition: background-color 0.2s; }
        
        .node-port.key-port { 
            position: absolute;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 14px; 
            height: 14px; 
            border-radius: 4px; 
        }
        .node-port:hover { background-color: var(--accent-green); }
        .node-port.connected { background-color: var(--accent-green); }
        #connection-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .connection-line { stroke: var(--accent-green); stroke-width: 2.5px; fill: none; pointer-events: stroke; transition: stroke-width 0.2s, stroke 0.2s; opacity: 0.8; }
        .connection-line:hover { stroke: var(--accent-red); stroke-width: 5px; cursor: pointer; opacity: 1; }
        .temp-line { stroke: var(--accent-green); stroke-width: 3px; stroke-dasharray: 6,6; fill: none; }
        .controls-container { position: fixed; top: 20px; left: 20px; z-index: 100; display: flex; gap: 10px; align-items: center; background-color: rgba(42, 44, 48, 0.8); backdrop-filter: blur(5px); padding: 8px; border-radius: 8px; border: 1px solid var(--border-color); }
        .controls-container button { background-color: var(--accent-green); color: var(--bg-dark); font-weight: bold; }
        .controls-container button, .controls-container select { padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; transition: background-color 0.2s, color 0.2s; }
        .controls-container button:hover { background-color: var(--accent-green-hover); }
        .controls-container select { background-color: var(--node-bg); color: var(--text-light); border: 1px solid var(--border-color); }
        
        .header-buttons { display: flex; align-items: center; gap: 4px; }
        .delete-node-btn, .refresh-node-btn { background: none; border: none; color: var(--text-dark); cursor: pointer; font-size: 1.1rem; padding: 2px 4px; border-radius: 4px; transition: color 0.2s; }
        .delete-node-btn:hover, .refresh-node-btn:hover { color: var(--accent-red); }
        .refresh-node-btn:hover { color: var(--accent-green); }
        
        #zoom-controls { position: fixed; bottom: 20px; right: 20px; z-index: 100; display: flex; flex-direction: column; gap: 2px; }
        #zoom-controls button { background-color: var(--node-bg); border: 1px solid var(--border-color); color: var(--text-light); width: 40px; height: 40px; font-size: 24px; font-weight: bold; cursor: pointer; transition: background-color 0.2s, color 0.2s; display: flex; justify-content: center; align-items: center; padding-bottom: 4px; }
        #zoom-controls button:first-child { border-radius: 8px 8px 0 0; }
        #zoom-controls button:last-child { border-radius: 0 0 8px 8px; }
        #zoom-controls button:hover { background-color: var(--accent-green); color: var(--bg-dark); }
        
        /* Options Menu */
        #options-container { position: fixed; bottom: 20px; left: 20px; z-index: 101; }
        #options-btn { background-color: var(--node-bg); border: 1px solid var(--border-color); color: var(--text-light); width: 40px; height: 40px; font-size: 24px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, color 0.2s; display: flex; justify-content: center; align-items: center; }
        #options-btn:hover { background-color: var(--accent-green); color: var(--bg-dark); }
        #options-menu { display: none; position: absolute; bottom: 50px; left: 0; background-color: var(--node-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 10px; min-width: 250px; box-shadow: 0 10px 20px rgba(0,0,0,0.3); }
        #options-menu.show { display: block; }
        .options-menu-item { display: flex; flex-direction: column; gap: 8px; justify-content: space-between; align-items: center; padding: 8px 0; font-size: 0.9rem; }
        .options-menu-item:not(:last-child) { border-bottom: 1px solid var(--border-color); padding-bottom: 12px; margin-bottom: 8px;}
        .menu-description-text { font-size: 0.75rem; color: var(--text-dark); padding-top: 8px; text-align: left; line-height: 1.4;}
        #clear-all-btn, #save-state-btn, #load-state-btn, #copy-link-btn { width: 100%; background-color: var(--accent-orange); color: var(--text-light); font-weight: bold; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer; transition: background-color 0.2s; }
        #clear-all-btn { background-color: var(--accent-orange); color: var(--bg-dark); }
        #clear-all-btn:hover { background-color: var(--accent-orange-hover); }
        #save-state-btn { background-color: var(--accent-green); color: var(--bg-dark); }
        #save-state-btn:hover { background-color: var(--accent-green-hover); }
        #copy-link-btn { background-color: var(--accent-cyan); color: var(--bg-dark); }
        #copy-link-btn:hover { background-color: var(--accent-cyan-hover); }
        #load-state-btn { background-color: var(--node-bg); }
        #load-state-btn:hover { background-color: var(--border-color); }
        .options-label-toggle { width: 100%; display: flex; justify-content: space-between; align-items: center; }

        /* Custom Scrollbars */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-green);
        }

    </style>
</head>
<body>
    <div id="graph-container"><div id="world-container"><svg id="connection-svg"></svg></div></div>
    
    <div class="controls-container">
        <select id="node-type-select"></select>
        <button id="add-node-btn">Add Node</button>
    </div>

    <div id="options-container">
        <div id="options-menu">
            <div class="options-menu-item">
                <div class="options-label-toggle">
                    <label for="hide-modern-toggle">Pen and Paper Mode</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="hide-modern-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                 <p class="menu-description-text">
                    This app is intended to help build and crack 'classic' ciphers possible via pen-and-paper techniques pre-dating computing. This app has some modern encodings and hashing available to play with, but the focus of this app is not modern day encryption schemes.
                </p>
            </div>
            <div class="options-menu-item">
                 <button id="save-state-btn">Save Current Nodes</button>
                 <button id="load-state-btn">Load Saved Nodes</button>
                 <button id="copy-link-btn">Copy Share Link</button>
            </div>
             <div class="options-menu-item">
                 <button id="clear-all-btn">Clear All Nodes</button>
            </div>
        </div>
        <button id="options-btn" title="Options">&#x2699;</button> <!-- Gear Icon -->
        <input type="file" id="load-state-input" style="display: none;" accept=".json">
    </div>

    <div id="zoom-controls">
        <button id="zoom-in-btn">+</button>
        <button id="zoom-out-btn">-</button>
    </div>

    <script>
        // --- DOM Elements ---
        const graphContainer = document.getElementById('graph-container');
        const worldContainer = document.getElementById('world-container');
        let svg = document.getElementById('connection-svg');
        const addNodeButton = document.getElementById('add-node-btn');
        const nodeTypeSelect = document.getElementById('node-type-select');
        const zoomInButton = document.getElementById('zoom-in-btn');
        const zoomOutButton = document.getElementById('zoom-out-btn');
        const optionsButton = document.getElementById('options-btn');
        const optionsMenu = document.getElementById('options-menu');
        const clearAllButton = document.getElementById('clear-all-btn');
        const hideModernToggle = document.getElementById('hide-modern-toggle');
        const saveStateButton = document.getElementById('save-state-btn');
        const loadStateButton = document.getElementById('load-state-btn');
        const loadStateInput = document.getElementById('load-state-input');
        const copyLinkButton = document.getElementById('copy-link-btn');

        // --- State Variables ---
        let nodes = [], connections = [], nodeIdCounter = 0, connectionIdCounter = 0;
        let draggingNode = null, isConnecting = false, sourceNodeIdForConnection = null, sourcePortElement = null, tempLine = null;
        let scale = 1, panX = 0, panY = 0, isPanning = false;
        let settings = { hideModern: true };

        // --- Hashing Functions ---
        function md5(string){function RotateLeft(lValue,iShiftBits){return(lValue<<iShiftBits)|(lValue>>>(32-iShiftBits));}function AddUnsigned(lX,lY){var lX4,lY4,lX8,lY8,lResult;lX4=(lX&0x40000000);lY4=(lY&0x40000000);lX8=(lX&0x80000000);lY8=(lY&0x80000000);lResult=(lX&0x3FFFFFFF)+(lY&0x3FFFFFFF);if(lX4&lY4){return(lResult^0x80000000^lX8^lY8);}if(lX4|lY4){if(lResult&0x40000000){return(lResult^0xC0000000^lX8^lY8);}else{return(lResult^0x40000000^lX8^lY8);}}else{return(lResult^lX8^lY8);}}function F(x,y,z){return(x&y)|((~x)&z);}function G(x,y,z){return(x&z)|(y&(~z));}function H(x,y,z){return(x^y^z);}function I(x,y,z){return(y^(x|(~z)));}function FF(a,b,c,d,x,s,ac){a=AddUnsigned(a,AddUnsigned(AddUnsigned(F(b,c,d),x),ac));return AddUnsigned(RotateLeft(a,s),b);}function GG(a,b,c,d,x,s,ac){a=AddUnsigned(a,AddUnsigned(AddUnsigned(G(b,c,d),x),ac));return AddUnsigned(RotateLeft(a,s),b);}function HH(a,b,c,d,x,s,ac){a=AddUnsigned(a,AddUnsigned(AddUnsigned(H(b,c,d),x),ac));return AddUnsigned(RotateLeft(a,s),b);}function II(a,b,c,d,x,s,ac){a=AddUnsigned(a,AddUnsigned(AddUnsigned(I(b,c,d),x),ac));return AddUnsigned(RotateLeft(a,s),b);}function ConvertToWordArray(string){var lWordCount;var lMessageLength=string.length;var lNumberOfWords_temp1=lMessageLength+8;var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1%64))/64;var lNumberOfWords=(lNumberOfWords_temp2+1)*16;var lWordArray=Array(lNumberOfWords-1);var lBytePosition=0;var lByteCount=0;while(lByteCount<lMessageLength){lWordCount=(lByteCount-(lByteCount%4))/4;lBytePosition=(lByteCount%4)*8;lWordArray[lWordCount]=(lWordArray[lWordCount]|(string.charCodeAt(lByteCount)<<lBytePosition));lByteCount++;}lWordCount=(lByteCount-(lByteCount%4))/4;lBytePosition=(lByteCount%4)*8;lWordArray[lWordCount]=lWordArray[lWordCount]|(0x80<<lBytePosition);lWordArray[lNumberOfWords-2]=lMessageLength<<3;lWordArray[lNumberOfWords-1]=lMessageLength>>>29;return lWordArray;}function WordToHex(lValue){var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;for(lCount=0;lCount<=3;lCount++){lByte=(lValue>>>(lCount*8))&255;WordToHexValue_temp="0"+lByte.toString(16);WordToHexValue=WordToHexValue+WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);}return WordToHexValue;}function Utf8Encode(string){string=string.replace(/\r\n/g,"\n");var utftext="";for(var n=0;n<string.length;n++){var c=string.charCodeAt(n);if(c<128){utftext+=String.fromCharCode(c);}else if((c>127)&&(c<2048)){utftext+=String.fromCharCode((c>>6)|192);utftext+=String.fromCharCode((c&63)|128);}else{utftext+=String.fromCharCode((c>>12)|224);utftext+=String.fromCharCode(((c>>6)&63)|128);utftext+=String.fromCharCode((c&63)|128);}}return utftext;}var x=Array();var k,AA,BB,CC,DD,a,b,c,d;var S11=7,S12=12,S13=17,S14=22;var S21=5,S22=9,S23=14,S24=20;var S31=4,S32=11,S33=16,S34=23;var S41=6,S42=10,S43=15,S44=21;string=Utf8Encode(string);x=ConvertToWordArray(string);a=0x67452301;b=0xEFCDAB89;c=0x98BADCFE;d=0x10325476;for(k=0;k<x.length;k+=16){AA=a;BB=b;CC=c;DD=d;a=FF(a,b,c,d,x[k+0],S11,0xD76AA478);d=FF(d,a,b,c,x[k+1],S12,0xE8C7B756);c=FF(c,d,a,b,x[k+2],S13,0x242070DB);b=FF(b,c,d,a,x[k+3],S14,0xC1BDCEEE);a=FF(a,b,c,d,x[k+4],S11,0xF57C0FAF);d=FF(d,a,b,c,x[k+5],S12,0x4787C62A);c=FF(c,d,a,b,x[k+6],S13,0xA8304613);b=FF(b,c,d,a,x[k+7],S14,0xFD469501);a=FF(a,b,c,d,x[k+8],S11,0x698098D8);d=FF(d,a,b,c,x[k+9],S12,0x8B44F7AF);c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);a=FF(a,b,c,d,x[k+12],S11,0x6B901122);d=FF(d,a,b,c,x[k+13],S12,0xFD987193);c=FF(c,d,a,b,x[k+14],S13,0xA679438E);b=FF(b,c,d,a,x[k+15],S14,0x49B40821);a=GG(a,b,c,d,x[k+1],S21,0xF61E2562);d=GG(d,a,b,c,x[k+6],S22,0xC040B340);c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);b=GG(b,c,d,a,x[k+0],S24,0xE9B6C7AA);a=GG(a,b,c,d,x[k+5],S21,0xD62F105D);d=GG(d,a,b,c,x[k+10],S22,0x2441453);c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);b=GG(b,c,d,a,x[k+4],S24,0xE7D3FBC8);a=GG(a,b,c,d,x[k+9],S21,0x21E1CDE6);d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);c=GG(c,d,a,b,x[k+3],S23,0xF4D50D87);b=GG(b,c,d,a,x[k+8],S24,0x455A14ED);a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);d=GG(d,a,b,c,x[k+2],S22,0xFCEFA3F8);c=GG(c,d,a,b,x[k+7],S23,0x676F02D9);b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);a=HH(a,b,c,d,x[k+5],S31,0xFFFA3942);d=HH(d,a,b,c,x[k+8],S32,0x8771F681);c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);a=HH(a,b,c,d,x[k+1],S31,0xA4BEEA44);d=HH(d,a,b,c,x[k+4],S32,0x4BDECFA9);c=HH(c,d,a,b,x[k+7],S33,0xF6BB4B60);b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);d=HH(d,a,b,c,x[k+0],S32,0xEAA127FA);c=HH(c,d,a,b,x[k+3],S33,0xD4EF3085);b=HH(b,c,d,a,x[k+6],S34,0x4881D05);a=HH(a,b,c,d,x[k+9],S31,0xD9D4D039);d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);b=HH(b,c,d,a,x[k+2],S34,0xC4AC5665);a=II(a,b,c,d,x[k+0],S41,0xF4292244);d=II(d,a,b,c,x[k+7],S42,0x432AFF97);c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);b=II(b,c,d,a,x[k+5],S44,0xFC93A039);a=II(a,b,c,d,x[k+12],S41,0x655B59C3);d=II(d,a,b,c,x[k+3],S42,0x8F0CCC92);c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);b=II(b,c,d,a,x[k+1],S44,0x85845DD1);a=II(a,b,c,d,x[k+8],S41,0x6FA87E4F);d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);c=II(c,d,a,b,x[k+6],S43,0xA3014314);b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);a=II(a,b,c,d,x[k+4],S41,0xF7537E82);d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);c=II(c,d,a,b,x[k+2],S43,0x2AD7D2BB);b=II(b,c,d,a,x[k+9],S44,0xEB86D391);a=AddUnsigned(a,AA);b=AddUnsigned(b,BB);c=AddUnsigned(c,CC);d=AddUnsigned(d,DD);}var temp=WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);return temp.toLowerCase();}

        // --- Node Definitions Registry ---
        const NODE_GROUP_ORDER = ['Input', 'Text Processing','Encoding', 'Ciphers', 'Hashing', 'Analysis'];
        const MORSE_CODE = { 'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '0': '-----', ' ': '/' };
        const MORSE_REVERSE = Object.fromEntries(Object.entries(MORSE_CODE).map(([k, v]) => [v, k]));
        const ENGLISH_FREQUENCIES = { A: 0.08167, B: 0.01492, C: 0.02782, D: 0.04253, E: 0.12702, F: 0.02228, G: 0.02015, H: 0.06094, I: 0.06966, J: 0.00153, K: 0.00772, L: 0.04025, M: 0.02406, N: 0.06749, O: 0.07507, P: 0.01929, Q: 0.00095, R: 0.05987, S: 0.06327, T: 0.09056, U: 0.02758, V: 0.00978, W: 0.02360, X: 0.00150, Y: 0.01974, Z: 0.00074 };


        const NODE_DEFINITIONS = {
            // --- Input ---
            'text-input': { name: 'Text Input', group: 'Input', isModern: false, params: [], processor: (text) => text },
            'generate_alphabet': { name: 'Generate Alphabet', group: 'Input', isModern: false, keyParam: 'remove', params: [{ name: 'remove', type: 'text', defaultValue: '' }], processor: (text, params) => { let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; const toRemove = (params.remove || '').toUpperCase().split(''); return alphabet.split('').filter(c => !toRemove.includes(c)).join(''); } },
            'generate_keyword_alphabet': { name: 'Generate Keyword Alphabet', group: 'Input', isModern: false, keyParam: 'keyword', params: [{ name: 'keyword', type: 'text', defaultValue: 'KRYPTOS' }], processor: (text, params) => { const key = (params.keyword || '').toUpperCase().replace(/[^A-Z]/g, ''); const uniqueChars = [...new Set(key.split(''))]; const remaining = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').filter(c => !uniqueChars.includes(c)); return uniqueChars.concat(remaining).join(''); } },
            'random_number': { name: 'Random Number', group: 'Input', isModern: false, params: [{ name: 'min', type: 'number', defaultValue: 1, min: -99999, max: 99999 }, { name: 'max', type: 'number', defaultValue: 100, min: -99999, max: 99999 }], processor: (text, params) => { const min = Math.ceil(params.min); const max = Math.floor(params.max); return String(Math.floor(Math.random() * (max - min + 1)) + min); } },
            
            // --- Text Processing ---
            'display_text': { name: 'Display Text', group: 'Text Processing', isModern: false, params: [], processor: (text) => text },
            'concat': { name: 'Concat', group: 'Text Processing', isModern: false, hasTwoInputs: true, params: [{ name: 'delimiter', type: 'text', defaultValue: '' }], processor: (inputs, params) => { return `${inputs.text1}${params.delimiter}${inputs.text2}`; } },
            'simple_replace': { name: 'Simple Replace', group: 'Text Processing', isModern: false, params: [{ name: 'find', type: 'text', defaultValue: '' }, { name: 'replace', type: 'text', defaultValue: '' }], processor: (text, params) => { if (!params.find) return text; return text.replaceAll(params.find, params.replace); } },
            'case_change': { name: 'Case Change', group: 'Text Processing', isModern: false, params: [{ name: 'mode', type: 'toggle', labels: ['UPPER', 'lower'], defaultValue: 'UPPER' }], processor: (text, params) => { if (params.mode === 'UPPER') return text.toUpperCase(); return text.toLowerCase(); } },
            'reverse': { name: 'Reverse', group: 'Text Processing', isModern: false, params: [], processor: (text) => text.split('').reverse().join('') },
            'trim': { name: 'Trim Whitespace', group: 'Text Processing', isModern: false, params: [], processor: (text) => text.replace(/\s+/g, '') },
            'split_every_x': { name: 'Split Every X', group: 'Text Processing', isModern: false, params: [{ name: 'x', type: 'number', defaultValue: 3, min: 1 }, { name: 'delimiter', type: 'text', defaultValue: ' ' } ], processor: (text, params) => { if (!text) return ''; const x = Math.max(1, Math.floor(params.x)); const regex = new RegExp(`.{1,${x}}`, 'g'); const matches = text.match(regex); return matches ? matches.join(params.delimiter) : ''; } },
            'repeat_text': { name: 'Repeat Text', group: 'Text Processing', isModern: false, params: [{ name: 'count', type: 'number', defaultValue: 2, min: 0 }, { name: 'delimiter', type: 'text', defaultValue: '' }], processor: (text, params) => { const count = Math.max(0, Math.floor(params.count)); if (count === 0 || !text) return ''; const arr = Array(count).fill(text); return arr.join(params.delimiter); } },
            'regex_replace': { name: 'Regex Replace', group: 'Text Processing', isModern: false, params: [{ name: 'pattern', type: 'text', defaultValue: '' }, { name: 'flags', type: 'text', defaultValue: 'g' }, { name: 'replace', type: 'text', defaultValue: '' }], processor: (text, params) => { try { const regex = new RegExp(params.pattern, params.flags); return text.replace(regex, params.replace); } catch (e) { return `Invalid Regex: ${e.message}`; } } },
            'regex_extract': { name: 'Regex Extract', group: 'Text Processing', isModern: false, params: [{ name: 'pattern', type: 'text', defaultValue: '' }, { name: 'flags', type: 'text', defaultValue: 'g' }], processor: (text, params) => { try { const regex = new RegExp(params.pattern, params.flags); const matches = text.match(regex); return matches ? matches.join('\n') : '[No Matches]'; } catch (e) { return `Invalid Regex: ${e.message}`; } } },
            'get_unique_chars': { name: 'Get Unique Characters', group: 'Text Processing', isModern: false, params: [], processor: (text, params) => { return [...new Set(text.split(''))].join(''); } },
            'count_occurrences': { name: 'Count Occurrences', group: 'Text Processing', isModern: false, params: [{ name: 'pattern', type: 'text', defaultValue: 'a' }, { name: 'flags', type: 'text', defaultValue: 'g' }], processor: (text, params) => { try { const regex = new RegExp(params.pattern, params.flags); const matches = text.match(regex); return matches ? String(matches.length) : '0'; } catch (e) { return `Invalid Regex: ${e.message}`; } } },

            // --- Math ---
            'add': { name: 'Add', group: 'Math', isModern: false, hasTwoInputs: true, params: [], processor: (inputs) => { const n1 = parseFloat(inputs.text1); const n2 = parseFloat(inputs.text2); return (isNaN(n1) || isNaN(n2)) ? 'NaN' : String(n1 + n2); } },
            'subtract': { name: 'Subtract', group: 'Math', isModern: false, hasTwoInputs: true, params: [], processor: (inputs) => { const n1 = parseFloat(inputs.text1); const n2 = parseFloat(inputs.text2); return (isNaN(n1) || isNaN(n2)) ? 'NaN' : String(n1 - n2); } },
            'multiply': { name: 'Multiply', group: 'Math', isModern: false, hasTwoInputs: true, params: [], processor: (inputs) => { const n1 = parseFloat(inputs.text1); const n2 = parseFloat(inputs.text2); return (isNaN(n1) || isNaN(n2)) ? 'NaN' : String(n1 * n2); } },
            'divide': { name: 'Divide', group: 'Math', isModern: false, hasTwoInputs: true, params: [], processor: (inputs) => { const n1 = parseFloat(inputs.text1); const n2 = parseFloat(inputs.text2); if (n2 === 0) return 'Infinity'; return (isNaN(n1) || isNaN(n2)) ? 'NaN' : String(n1 / n2); } },

            // --- Encoding ---
            'binary': { name: 'Binary Conversion', group: 'Encoding', isModern: true, params: [{ name: 'mode', type: 'toggle', labels: ['Encode', 'Decode'], defaultValue: 'Encode' }], processor: (text, params) => { if (params.mode === 'Encode') { return text.split('').map(c => c.charCodeAt(0).toString(2).padStart(8, '0')).join(' '); } else { if (/[^01\s]/.test(text)) return "Invalid Binary"; return text.trim().split(/\s+/).map(b => b ? String.fromCharCode(parseInt(b, 2)) : '').join(''); } } },
            'base64': { name: 'Base64', group: 'Encoding', isModern: true, params: [{ name: 'mode', type: 'toggle', labels: ['Encode', 'Decode'], defaultValue: 'Encode' }], processor: (text, params) => { try { if (params.mode === 'Encode') { return btoa(unescape(encodeURIComponent(text))); } else { return decodeURIComponent(escape(atob(text))); } } catch(e) { return "Invalid Base64"; } } },
            'url': { name: 'URL', group: 'Encoding', isModern: true, params: [{ name: 'mode', type: 'toggle', labels: ['Encode', 'Decode'], defaultValue: 'Encode' }], processor: (text, params) => params.mode === 'Encode' ? encodeURIComponent(text) : decodeURIComponent(text) },
            'hex': { name: 'Hex', group: 'Encoding', isModern: true, params: [{ name: 'mode', type: 'toggle', labels: ['Encode', 'Decode'], defaultValue: 'Encode' }], processor: (text, params) => { if (params.mode === 'Encode') { return text.split('').map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(''); } else { return text.match(/.{1,2}/g)?.map(hex => String.fromCharCode(parseInt(hex, 16))).join('') ?? "Invalid Hex"; } } },
            'morse': { name: 'Morse Code', group: 'Encoding', isModern: false, params: [{ name: 'mode', type: 'toggle', labels: ['Encode', 'Decode'], defaultValue: 'Encode' }], processor: (text, params) => { text = text.toLowerCase(); if (params.mode === 'Encode') { return text.split('').map(c => MORSE_CODE[c] || '?').join(' '); } else { return text.trim().split(' ').map(c => MORSE_REVERSE[c] || '?').join(''); } } },
            
            // --- Ciphers ---
            'affine': { name: 'Affine Cipher', group: 'Ciphers', isModern: false, params: [{name: 'a', type: 'number', defaultValue: 5}, {name: 'b', type: 'number', defaultValue: 8}, {name: 'mode', type: 'toggle', labels: ['Encrypt', 'Decrypt'], defaultValue: 'Encrypt'}], processor(text, params) { const m = 26; const a = params.a; const b = params.b; const modInverse = (a, m) => { for(let x = 1; x < m; x++) if(((a % m) * (x % m)) % m == 1) return x; return 1; }; if (params.mode === 'Encrypt') { return text.toUpperCase().replace(/[A-Z]/g, c => { const charCode = c.charCodeAt(0); return String.fromCharCode((a * (charCode - 65) + b) % m + 65); }); } else { const aInv = modInverse(a, m); return text.toUpperCase().replace(/[A-Z]/g, c => { const charCode = c.charCodeAt(0); return String.fromCharCode((aInv * (charCode - 65 - b + m)) % m + 65); }); } } },
            'atbash': { name: 'Atbash Cipher', group: 'Ciphers', isModern: false, params: [], processor: (text) => { const a = "abcdefghijklmnopqrstuvwxyz"; const z = "zyxwvutsrqponmlkjihgfedcba"; return text.toLowerCase().replace(/[a-z]/g, c => z[a.indexOf(c)]); } },
            'a1z26': { name: 'A1Z26 Cipher', group: 'Ciphers', isModern: false, params: [{ name: 'mode', type: 'toggle', labels: ['Encode', 'Decode'], defaultValue: 'Encode' }], processor: (text, params) => { if (params.mode === 'Encode') { return text.toLowerCase().split('').map(char => { const code = char.charCodeAt(0); if (code >= 97 && code <= 122) { return code - 96; } return null; }).filter(val => val !== null).join(' '); } else { if (/[^0-9\s]/.test(text)) return "Invalid Input"; return text.trim().split(/\s+/).map(numStr => { const num = parseInt(numStr, 10); if (num >= 1 && num <= 26) { return String.fromCharCode(num + 96); } return '?'; }).join(''); } } },
            'baconian': { name: 'Baconian Cipher', group: 'Ciphers', isModern: false, params: [{name: 'mode', type: 'toggle', labels: ['Encode', 'Decode'], defaultValue: 'Encode'}], processor(text, params) { const baconianMap = { A:'AAAAA', B:'AAAAB', C:'AAABA', D:'AAABB', E:'AABAA', F:'AABAB', G:'AABBA', H:'AABBB', I:'ABAAA', J:'ABAAB', K:'ABABA', L:'ABABB', M:'ABBAA', N:'ABBAB', O:'ABBBA', P:'ABBBB', Q:'BAAAA', R:'BAAAB', S:'BAABA', T:'BAABB', U:'BABAA', V:'BABAB', W:'BABBA', X:'BABBB', Y:'BBAAA', Z:'BBAAB' }; const reverseBaconianMap = Object.fromEntries(Object.entries(baconianMap).map(([k,v])=>[v,k])); if (params.mode === 'Encode') { return text.toUpperCase().replace(/[^A-Z]/g, '').split('').map(c => baconianMap[c]).join(' '); } else { return text.replace(/[^AaBb]/g, '').toUpperCase().match(/.{1,5}/g)?.map(c => reverseBaconianMap[c]).join('') ?? 'Invalid Baconian'; } } },
            'bifid': { name: 'Bifid Cipher', group: 'Ciphers', isModern: false, keyParam: 'key', params: [{name: 'key', type: 'text', defaultValue: 'PHQGIUMEAYNOFDXKRCVSZWB'}, {name: 'mode', type: 'toggle', labels: ['Encrypt', 'Decrypt'], defaultValue: 'Encrypt'}], processor(text, params) { const key = params.key.toUpperCase().replace(/[^A-Z]/g, ''); if (new Set(key).size !== 25) return "Key must have 25 unique letters"; text = text.toUpperCase().replace(/J/g, 'I').replace(/[^A-Z]/g, ''); const coords = {}; const chars = {}; for(let i=0; i<25; i++) { const char = key[i]; const row = Math.floor(i / 5) + 1; const col = i % 5 + 1; coords[char] = `${row}${col}`; chars[`${row}${col}`] = char; } if (params.mode === 'Encrypt') { let rows = '', cols = ''; for(const char of text) { const c = coords[char]; rows += c[0]; cols += c[1]; } const combined = rows + cols; let result = ''; for (let i = 0; i < combined.length; i += 2) { result += chars[combined.slice(i, i+2)]; } return result; } else { let combined = ''; for(const char of text) { combined += coords[char]; } const half = combined.length / 2; const rows = combined.slice(0, half); const cols = combined.slice(half); let result = ''; for (let i = 0; i < rows.length; i++) { result += chars[`${rows[i]}${cols[i]}`]; } return result; } } },
            'polybius_square': { name: 'Polybius Square', group: 'Ciphers', isModern: false, params: [{name: 'mode', type: 'toggle', labels: ['Encrypt', 'Decrypt'], defaultValue: 'Encrypt'}], processor(text, params) { const square = { 'A': '11', 'B': '12', 'C': '13', 'D': '14', 'E': '15', 'F': '21', 'G': '22', 'H': '23', 'I': '24', 'J': '24', 'K': '25', 'L': '31', 'M': '32', 'N': '33', 'O': '34', 'P': '35', 'Q': '41', 'R': '42', 'S': '43', 'T': '44', 'U': '45', 'V': '51', 'W': '52', 'X': '53', 'Y': '54', 'Z': '55' }; const reverseSquare = Object.fromEntries(Object.entries(square).filter(([k,v]) => k !== 'J').map(([k,v])=>[v,k])); if (params.mode === 'Encrypt') { return text.toUpperCase().replace(/[^A-Z]/g, '').split('').map(c => square[c]).join(''); } else { return text.replace(/[^1-5]/g, '').match(/.{1,2}/g)?.map(c => reverseSquare[c]).join('') ?? 'Invalid Polybius'; } } },
            'railfence': { name: 'Rail Fence Cipher', group: 'Ciphers', isModern: false, keyParam: 'rails', params: [{ name: 'mode', type: 'toggle', labels: ['Encrypt', 'Decrypt'], defaultValue: 'Encrypt' }, { name: 'rails', type: 'number', defaultValue: 3, min: 2, max: 20 }], processor: (text, params) => { const rails = Math.floor(params.rails); if (rails < 2) return text; if (params.mode === 'Encrypt') { const fence = Array(rails).fill(0).map(() => []); let rail = 0, dir = 1; for (const char of text) { fence[rail].push(char); rail += dir; if (rail === 0 || rail === rails - 1) dir *= -1; } return [].concat(...fence).join(''); } else { const len = text.length; const fence = Array(rails).fill(0).map(() => []); const pattern = []; let rail=0, dir=1; for (let i=0; i<len; i++) { pattern.push(rail); rail+=dir; if (rail === 0 || rail === rails-1) dir *= -1; } for (let r=0; r<rails; r++) { for (let i=0; i<len; i++) { if (pattern[i] === r) fence[r].push('X'); } } let i=0; for (let r=0; r<rails; r++) { fence[r] = fence[r].map(() => text[i++]); } let out = ''; rail=0, dir=1; for (let i=0; i<len; i++) { out += fence[rail].shift(); rail+=dir; if (rail === 0 || rail === rails-1) dir *= -1; } return out; } } },
            'rot': { name: 'ROT Cipher', group: 'Ciphers', isModern: false, params: [{ name: 'rotation', type: 'number', defaultValue: 13, min: 0, max: 25 }], processor: (text, params) => { const r = parseInt(params.rotation, 10) % 26; if (r === 0) return text; return text.replace(/[a-zA-Z]/g, c => { const code = c.charCodeAt(0); const start = code <= 90 ? 65 : 97; return String.fromCharCode(((code - start + r) % 26) + start); }); } },
            'route_cipher': { name: 'Route Cipher (Box)', group: 'Ciphers', isModern: false, keyParam: 'cols', params: [{ name: 'cols', type: 'number', defaultValue: 4, min: 2 }, {name: 'mode', type: 'toggle', labels: ['Encrypt', 'Decrypt'], defaultValue: 'Encrypt'}], processor(text, params) { const cols = params.cols; if (cols < 2) return text; if(params.mode === 'Encrypt') { let out = ''; for (let i = 0; i < cols; i++) { for (let j = i; j < text.length; j += cols) { out += text[j]; } } return out; } else { const rows = Math.ceil(text.length / cols); const extra = rows * cols - text.length; const fullCols = cols - extra; let out = ''; let k=0; const grid = Array(rows).fill(0).map(() => Array(cols)); for (let j=0; j<cols; j++) { for (let i=0; i<rows; i++) { if (j >= fullCols && i === rows - 1) continue; grid[i][j] = text[k++]; } } for (let i=0; i<rows; i++) { for (let j=0; j<cols; j++) { if(grid[i][j]) out += grid[i][j]; } } return out; } } },
            'skip_transposition': { name: 'Skip Transposition', group: 'Ciphers', isModern: false, keyParam: 'skip', params: [{ name: 'skip', type: 'number', defaultValue: 3, min: 1, max: 100 }], processor: (text, params) => { const skip = Math.max(1, Math.floor(params.skip)); const source = text.split(''); const result = []; let pos = 0; if (source.length === 0) return ''; while (source.length > 0) { pos = (pos + skip - 1) % source.length; result.push(source.splice(pos, 1)[0]); } return result.join(''); } },
            'substitution': { name: 'Substitution Cipher', group: 'Ciphers', isModern: false, keyParam: 'key', params: [{ name: 'mode', type: 'toggle', labels: ['Encrypt', 'Decrypt'], defaultValue: 'Encrypt' }, { name: 'key', type: 'text', defaultValue: 'QWERTYUIOPASDFGHJKLZXCVBNM' }], processor: (text, params) => { const key = params.key.toUpperCase(); if (key.length !== 26 || new Set(key).size !== 26) return "Invalid Key (must be 26 unique letters)"; const abc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; const fromAbc = params.mode === 'Encrypt' ? abc : key; const toAbc = params.mode === 'Encrypt' ? key : abc; return text.toUpperCase().replace(/[A-Z]/g, c => toAbc[fromAbc.indexOf(c)]); } },
            'vigenere': { name: 'Vigenère Cipher', group: 'Ciphers', isModern: false, keyParam: 'key', params: [{ name: 'mode', type: 'toggle', labels: ['Encrypt', 'Decrypt'], defaultValue: 'Encrypt' }, { name: 'key', type: 'text', defaultValue: 'LEMON' }], processor: (text, params) => { const key = params.key.toLowerCase().replace(/[^a-z]/g, ''); if (!key) return text; let out = ''; for (let i = 0, j = 0; i < text.length; i++) { const c = text[i]; if (/[a-zA-Z]/.test(c)) { const start = c === c.toLowerCase() ? 97 : 65; const keyChar = key[j % key.length]; const shift = keyChar.charCodeAt(0) - 97; const dir = params.mode === 'Encrypt' ? 1 : -1; out += String.fromCharCode((c.charCodeAt(0) - start + (shift * dir) + 26) % 26 + start); j++; } else { out += c; } } return out; } },
            
            // --- Analysis ---
            'frequency_analysis': { name: 'Frequency Analysis', group: 'Analysis', isModern: false, params: [], processor: (text) => { const cleanedText = text.toUpperCase().replace(/[^A-Z]/g, ''); if (!cleanedText) return 'No letters to analyze.'; const counts = {}; const total = cleanedText.length; for (const char of cleanedText) { counts[char] = (counts[char] || 0) + 1; } return Object.entries(counts).sort((a,b) => b[1] - a[1]).map(([char, count]) => `${char}: ${((count / total) * 100).toFixed(2)}% (${count})`).join('\n'); }},
            'ioc': { name: 'Index of Coincidence', group: 'Analysis', isModern: false, params: [], processor: (text) => { const cleanedText = text.toUpperCase().replace(/[^A-Z]/g, ''); const N = cleanedText.length; if (N < 2) return 'Not enough text.'; const counts = {}; for(const char of cleanedText) { counts[char] = (counts[char] || 0) + 1; } const sum = Object.values(counts).reduce((acc, n) => acc + n * (n-1), 0); const ioc = sum / (N * (N - 1)); return `IoC: ${ioc.toFixed(4)}\n(English is ~0.0667)`; }},
            'chi_squared': { name: 'Chi-Squared', group: 'Analysis', isModern: false, params: [], processor: (text) => { const cleanedText = text.toUpperCase().replace(/[^A-Z]/g, ''); const N = cleanedText.length; if (N === 0) return 'No text to analyze.'; const observed = {}; for (const char of 'ABCDEFGHIJKLMNOPQRSTUVWXYZ') { observed[char] = 0; } for (const char of cleanedText) { observed[char]++; } let chi2 = 0; for (const char in observed) { const expected = ENGLISH_FREQUENCIES[char] * N; chi2 += Math.pow(observed[char] - expected, 2) / expected; } return `Score: ${chi2.toFixed(2)}\n(Lower is better)`; }},
            
            // --- Hashing ---
            'md5': { name: 'MD5 Hash', group: 'Hashing', isModern: true, params: [], processor: (text) => md5(text) },
            'sha256': { name: 'SHA-256 Hash', group: 'Hashing', isModern: true, params: [], processor: async (text) => { const d = new TextEncoder().encode(text); const hB = await crypto.subtle.digest('SHA-256', d); return Array.from(new Uint8Array(hB)).map(b => b.toString(16).padStart(2,'0')).join(''); } },
        };
        
        // --- Utility ---
        function generateId(prefix = 'node') { return `${prefix}-${nodeIdCounter++}`; }
        function generateConnectionId() { return `conn-${connectionIdCounter++}`; }
        function applyTransform() { worldContainer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`; }

        // --- Node Functions ---
        function createNode(x, y, nodeTypeKey) {
            const definition = NODE_DEFINITIONS[nodeTypeKey];
            if (!definition) return;

            const nodeId = generateId();
            const nodeElement = document.createElement('div');
            nodeElement.classList.add('node');
            nodeElement.id = nodeId;
            nodeElement.style.left = `${x}px`;
            nodeElement.style.top = `${y}px`;
            
            const isGenerator = definition.group === 'Input' && nodeTypeKey !== 'text-input';
            const hasParams = definition.params && definition.params.length > 0;
            const isReadOnly = hasParams || (nodeTypeKey !== 'text-input') || isGenerator;
            
            let currentText = "[Connect Input]";
            if (nodeTypeKey === 'text-input') currentText = "Edit Me!";
            if (isGenerator) {
                currentText = definition.processor("", definition.params.reduce((acc, p) => ({...acc, [p.name]: p.defaultValue }), {}));
            }

            const nodeData = { id: nodeId, x, y, type: nodeTypeKey, text: currentText, inputText: "", inputText2: "", isLoading: false, element: nodeElement, inputs: { text: null, text2: null, key: null }, outputs: [], params: {} };
            
            let paramsHTML = '';
            if (hasParams) {
                paramsHTML = '<div class="node-params">';
                definition.params.forEach(param => {
                    nodeData.params[param.name] = param.defaultValue;
                    let keyPortHTML = '';
                    if (definition.keyParam === param.name) {
                        keyPortHTML = `<div class="node-port key-port" data-port-type="key" data-node-id="${nodeId}"></div>`;
                    }
                    paramsHTML += `<div class="param-row ${keyPortHTML ? 'has-key-port' : ''}" data-param-row="${param.name}">${keyPortHTML}`;
                    const label = param.name.charAt(0).toUpperCase() + param.name.slice(1);
                    if (param.type === 'toggle') {
                        paramsHTML += `<label>${param.labels[0]}</label><label class="toggle-switch"><input type="checkbox" data-param="${param.name}" ${param.defaultValue === param.labels[1] ? 'checked' : ''}><span class="slider"></span></label><label>${param.labels[1]}</label>`;
                    } else if (param.type === 'number') {
                        paramsHTML += `<label>${label}</label><input type="number" class="param-input" style="width: 60px; text-align: center;" data-param="${param.name}" value="${param.defaultValue}" min="${param.min}" max="${param.max}">`;
                    } else if (param.type === 'text') {
                        paramsHTML += `<label>${label}</label><input type="text" class="param-input" data-param="${param.name}" value="${param.defaultValue}">`;
                    }
                    paramsHTML += `</div>`;
                });
                paramsHTML += '</div>';
            }
            
            const refreshButtonHTML = nodeTypeKey === 'random_number' ? `<button class="refresh-node-btn" title="Generate new number">&#x21bb;</button>` : '';

            let inputPortsHTML = `<div class="node-port" data-port-type="text" data-node-id="${nodeId}"></div>`;
            if (definition.hasTwoInputs) {
                inputPortsHTML += `<div class="node-port" data-port-type="text2" data-node-id="${nodeId}"></div>`;
            }

            nodeElement.innerHTML = `
                <div class="node-header"><span>${definition.name}</span><div class="header-buttons">${refreshButtonHTML}<button class="delete-node-btn" title="Delete Node">&times;</button></div></div>
                ${paramsHTML}
                <textarea class="node-text" ${isReadOnly ? 'readonly' : ''}>${currentText}</textarea>
                <div class="io-ports-container">
                    <div class="input-ports">${inputPortsHTML}</div>
                    <div class="output-ports"><div class="node-port" data-port-type="output" data-node-id="${nodeId}"></div></div>
                </div>`;
            
            nodeElement.addEventListener('mousedown', onNodeMouseDown);
            const textarea = nodeElement.querySelector('.node-text');
            if (nodeTypeKey === 'text-input') {
                textarea.addEventListener('input', (e) => { nodeData.text = e.target.value; propagateTextFromNode(nodeData.id, nodeData.text); });
            }
            textarea.addEventListener('focus', () => nodeElement.removeEventListener('mousedown', onNodeMouseDown));
            textarea.addEventListener('blur', () => nodeElement.addEventListener('mousedown', onNodeMouseDown));

            nodeElement.querySelectorAll('[data-param]').forEach(p_el => { p_el.addEventListener('input', (e) => handleParamChange(e, nodeId)); });
            nodeElement.querySelectorAll('.node-port[data-port-type]').forEach(p => p.addEventListener('mousedown', onPortMouseDown));
            nodeElement.querySelector('.delete-node-btn').addEventListener('click', (e) => { e.stopPropagation(); deleteNode(nodeId); });
            
            const refreshBtn = nodeElement.querySelector('.refresh-node-btn');
            if(refreshBtn) {
                refreshBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    processNode(nodeId);
                });
            }
            
            const resizeObserver = new ResizeObserver(() => {
                updateConnectionsForNode(nodeId);
            });
            resizeObserver.observe(nodeElement);
            nodeData.resizeObserver = resizeObserver;

            if (definition.group === 'Input' && nodeTypeKey !== 'text-input') {
                 nodeElement.querySelector('.input-ports').innerHTML = '';
            }
            if (nodeTypeKey === 'text-input') {
                nodeElement.querySelector('.input-ports').innerHTML = '';
            }


            worldContainer.appendChild(nodeElement);
            nodes.push(nodeData);
            return nodeData;
        }

        function handleParamChange(event, nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            const definition = NODE_DEFINITIONS[node.type];
            const paramName = event.target.dataset.param;
            if (event.target.type === 'checkbox') {
                const paramDef = definition.params.find(p => p.name === paramName);
                node.params[paramName] = event.target.checked ? paramDef.labels[1] : paramDef.labels[0];
            } else if (event.target.type === 'number') {
                node.params[paramName] = parseFloat(event.target.value) || 0;
            } else if (event.target.type === 'text') {
                node.params[paramName] = event.target.value;
            }
            processNode(nodeId);
        }
        
        function deleteNode(nodeIdToDelete) { 
            const nodeIndex = nodes.findIndex(n => n.id === nodeIdToDelete); 
            if (nodeIndex === -1) return; 
            
            // Disconnect resize observer first
            const node = nodes[nodeIndex];
            if (node.resizeObserver) {
                node.resizeObserver.disconnect();
            }
            
            connections = connections.filter(conn => {
                if (conn.fromNodeId === nodeIdToDelete || conn.toNodeId === nodeIdToDelete) {
                    if (conn.lineElement) conn.lineElement.remove();
                    return false;
                }
                return true;
            });
            
            node.element.remove(); 
            nodes.splice(nodeIndex, 1); 
            
            redrawAllConnections(); 
        }

        function onNodeMouseDown(e) { if (e.target.closest('.node-port, .node-text, button, .node-params, textarea')) return; e.stopPropagation(); draggingNode = nodes.find(n => n.id === e.currentTarget.id); if (!draggingNode) return; e.currentTarget.style.cursor = 'grabbing'; e.currentTarget.style.zIndex = '20'; document.addEventListener('mousemove', onNodeMouseMove); document.addEventListener('mouseup', onNodeMouseUp); }
        function onNodeMouseMove(e) { if (!draggingNode) return; e.preventDefault(); const newX = draggingNode.x + (e.movementX / scale); const newY = draggingNode.y + (e.movementY / scale); draggingNode.x = newX; draggingNode.y = newY; draggingNode.element.style.left = `${newX}px`; draggingNode.element.style.top = `${newY}px`; updateConnectionsForNode(draggingNode.id); }
        function onNodeMouseUp() { if (draggingNode) { draggingNode.element.style.cursor = 'grab'; draggingNode.element.style.zIndex = '10'; } draggingNode = null; document.removeEventListener('mousemove', onNodeMouseMove); document.removeEventListener('mouseup', onNodeMouseUp); }
        
        function onPortMouseDown(e) {
            e.stopPropagation();
            isConnecting = true;
            sourceNodeIdForConnection = e.currentTarget.dataset.nodeId;
            sourcePortElement = e.currentTarget;
            const worldRect = worldContainer.getBoundingClientRect();
            const sx = (e.clientX - worldRect.left)/scale;
            const sy = (e.clientY - worldRect.top)/scale;
            tempLine = document.createElementNS('http://www.w3.org/2000/svg','line');
            tempLine.setAttribute('x1', sx);
            tempLine.setAttribute('y1', sy);
            tempLine.setAttribute('x2', sx);
            tempLine.setAttribute('y2', sy);
            tempLine.classList.add('temp-line');
            svg.appendChild(tempLine);
            document.addEventListener('mousemove', onDrawingConnection);
            document.addEventListener('mouseup', onCompleteConnectionAttempt, { once: true });
        }
        function onDrawingConnection(e) { 
            if (!isConnecting || !tempLine) return; 
            e.preventDefault(); 
            const worldRect = worldContainer.getBoundingClientRect(); 
            tempLine.setAttribute('x2', (e.clientX-worldRect.left)/scale); 
            tempLine.setAttribute('y2', (e.clientY-worldRect.top)/scale); 
        }
        
        function onCompleteConnectionAttempt(e) {
            if (!isConnecting) return;
            const targetPort = e.target.closest('.node-port');
            if (targetPort && targetPort !== sourcePortElement) {
                const targetNodeId = targetPort.dataset.nodeId;
                const portType = targetPort.dataset.portType;
                if (targetNodeId !== sourceNodeIdForConnection && sourcePortElement.dataset.portType === 'output' && portType !== 'output') {
                     createConnection(sourceNodeIdForConnection, targetNodeId, portType);
                }
            }
             // Cleanup
            isConnecting = false;
            sourceNodeIdForConnection = null;
            sourcePortElement = null;
            if (tempLine) tempLine.remove();
            tempLine = null;
            document.removeEventListener('mousemove', onDrawingConnection);
        }

        function createConnection(fromNodeId, toNodeId, toPortType) { 
            if (toPortType === 'output') return;
            const existing = connections.find(c => c.fromNodeId === fromNodeId && c.toNodeId === toNodeId && c.portType === toPortType);
            if(existing) return; 
            const toNodeData = nodes.find(n=>n.id===toNodeId); 
            if (toNodeData) { const existingConn = connections.find(c=>c.toNodeId===toNodeId && c.portType === toPortType); if(existingConn) deleteConnection(existingConn.id, false); } 
            const connId = generateConnectionId(); 
            connections.push({id:connId, fromNodeId, toNodeId, portType: toPortType, lineElement:null}); 
            const fromNode = nodes.find(n=>n.id===fromNodeId); 
            fromNode?.outputs.push(connId); 
            toNodeData.inputs[toPortType] = connId;
            fromNode?.element.querySelector('.node-port[data-port-type="output"]').classList.add('connected'); 
            toNodeData?.element.querySelector(`[data-port-type="${toPortType}"]`)?.classList.add('connected'); 
            drawConnection(connections.slice(-1)[0]); 
            if(fromNode) {
                if (toPortType === 'key') {
                    receiveKey(toNodeId, fromNode.text);
                } else {
                    receiveText(toNodeId, fromNode.text, toPortType);
                }
            }
        }
        function deleteConnection(connId, redraw=true) { 
            const idx = connections.findIndex(c=>c.id===connId); if(idx===-1) return; 
            const conn = connections[idx]; 
            const fromNode = nodes.find(n=>n.id===conn.fromNodeId); 
            const toNode = nodes.find(n=>n.id===conn.toNodeId); 
            if(fromNode) {fromNode.outputs = fromNode.outputs.filter(id=>id!==conn.id); if(!fromNode.outputs.length) fromNode.element.querySelector('.node-port[data-port-type="output"]')?.classList.remove('connected');} 
            if(toNode) {
                toNode.inputs[conn.portType] = null;
                toNode.element.querySelector(`[data-port-type="${conn.portType}"]`)?.classList.remove('connected');
                if (conn.portType === 'key') {
                    receiveKey(toNode.id, null); // Revert to internal param
                } else {
                    receiveText(toNode.id, "[Connect Input]", conn.portType);
                }
            } 
            conn.lineElement?.remove(); connections.splice(idx,1); if(redraw) redrawAllConnections(); 
        }
        
        function drawConnection(conn) {
            const fromNode=nodes.find(n=>n.id===conn.fromNodeId);
            const toNode=nodes.find(n=>n.id===conn.toNodeId);
            if(!fromNode || !toNode) return;
            const fromPort = fromNode.element.querySelector('[data-port-type="output"]');
            const toPort = toNode.element.querySelector(`[data-port-type="${conn.portType}"]`);
            if(!fromPort || !toPort) return;
            
            const fromRect = fromPort.getBoundingClientRect();
            const toRect = toPort.getBoundingClientRect();
            const worldRect = worldContainer.getBoundingClientRect();

            const x1 = (fromRect.left + fromRect.width / 2 - worldRect.left) / scale;
            const y1 = (fromRect.top + fromRect.height / 2 - worldRect.top) / scale;
            const x2 = (toRect.left + toRect.width / 2 - worldRect.left) / scale;
            const y2 = (toRect.top + toRect.height / 2 - worldRect.top) / scale;
            
            // Orthogonal path calculation
            const midX = x1 + (x2-x1)/2;
            const pathData = `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;

            if(!conn.lineElement) {
                conn.lineElement = document.createElementNS('http://www.w3.org/2000/svg','path'); 
                conn.lineElement.classList.add('connection-line'); 
                conn.lineElement.dataset.connectionId = conn.id; 
                svg.appendChild(conn.lineElement);
            }
            conn.lineElement.setAttribute('d',pathData);
        }

        function updateConnectionsForNode(id) { connections.forEach(c => { if(c.fromNodeId === id || c.toNodeId === id) drawConnection(c); }); }
        function redrawAllConnections() { svg.innerHTML=''; connections.forEach(c=>{c.lineElement=null; drawConnection(c);}); }

        async function propagateTextFromNode(sourceNodeId, text) { 
            for (const conn of connections.filter(c => c.fromNodeId === sourceNodeId)) {
                 if (conn.portType === 'key') {
                    await receiveKey(conn.toNodeId, text);
                } else {
                    await receiveText(conn.toNodeId, text, conn.portType);
                }
            } 
        }

        async function receiveKey(targetNodeId, incomingKey) {
            const targetNode = nodes.find(n => n.id === targetNodeId);
            if (!targetNode) return;
            const definition = NODE_DEFINITIONS[targetNode.type];
            if (!definition || !definition.keyParam) return;
            
            const paramName = definition.keyParam;
            const paramInput = targetNode.element.querySelector(`[data-param="${paramName}"]`);

            if (incomingKey === null) { // Disconnected
                paramInput.disabled = false;
                targetNode.params[paramName] = paramInput.type === 'number' ? parseFloat(paramInput.value) : paramInput.value;
            } else { // Connected
                paramInput.disabled = true;
                targetNode.params[paramName] = paramInput.type === 'number' ? parseFloat(incomingKey) : incomingKey;
                paramInput.value = incomingKey;
            }
            await processNode(targetNodeId);
        }

        async function receiveText(targetNodeId, incomingText, portType = 'text') {
            const targetNode = nodes.find(n => n.id === targetNodeId);
            if (!targetNode) return;
            const definition = NODE_DEFINITIONS[targetNode.type];
            if (definition.group === 'Input') return;
            
            if (portType === 'text') targetNode.inputText = incomingText;
            if (portType === 'text2') targetNode.inputText2 = incomingText;
            
            await processNode(targetNodeId);
        }

        async function processNode(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const definition = NODE_DEFINITIONS[node.type];

            let processedText;
            try {
                if (definition.group === 'Input') {
                     processedText = definition.processor(null, node.params);
                } else {
                    const textToProcess = definition.hasTwoInputs 
                        ? { text1: node.inputText, text2: node.inputText2 } 
                        : node.inputText;
                    processedText = await definition.processor(textToProcess, node.params);
                }
            } catch (e) {
                processedText = `Error: ${e.message}`;
            }
            
            node.text = processedText;
            node.element.querySelector('.node-text').value = processedText;
            await propagateTextFromNode(node.id, processedText);
        }
        
        function populateDropdown() {
            let filteredNodes = Object.entries(NODE_DEFINITIONS);
            if (settings.hideModern) {
                filteredNodes = filteredNodes.filter(([key, def]) => !def.isModern);
            }

            const groups = {};
            filteredNodes.forEach(([key, def]) => {
                if (!groups[def.group]) groups[def.group] = [];
                groups[def.group].push({ key, name: def.name });
            });
            
            nodeTypeSelect.innerHTML = NODE_GROUP_ORDER.map(groupName => {
                if (!groups[groupName]) return '';
                return `<optgroup label="${groupName.replace('_', ' ')}">${
                    groups[groupName]
                        .sort((a, b) => a.name.localeCompare(b.name))
                        .map(item => `<option value="${item.key}">${item.name}</option>`)
                        .join('')
                }</optgroup>`;
            }).join('');
        }

        function handleZoom(direction) {
            const zoomSpeed = 0.1;
            const oldScale = scale;
            const delta = direction === 'in' ? zoomSpeed : -zoomSpeed;
            scale = Math.max(0.2, Math.min(2, scale + delta));

            const centerX = graphContainer.clientWidth / 2;
            const centerY = graphContainer.clientHeight / 2;

            panX = centerX - (centerX - panX) * (scale / oldScale);
            panY = centerY - (centerY - panY) * (scale / oldScale);
            
            applyTransform();
        }
        
        function clearAll() {
            worldContainer.innerHTML = '';
            svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.id = 'connection-svg';
            worldContainer.appendChild(svg);
            nodes.forEach(n => n.element.remove());
            nodes = [];
            connections = [];
            nodeIdCounter = 0; 
            connectionIdCounter = 0;
            optionsMenu.classList.remove('show');
        }

        function saveState() {
            const state = {
                nodes: nodes.map(n => ({
                    id: n.id,
                    type: n.type,
                    x: n.x,
                    y: n.y,
                    width: n.element.offsetWidth,
                    height: n.element.offsetHeight,
                    params: n.params,
                    text: n.type === 'text-input' ? n.text : undefined
                })),
                connections: connections.map(c => ({
                    fromNodeId: c.fromNodeId,
                    toNodeId: c.toNodeId,
                    portType: c.portType
                })),
                nodeIdCounter,
                connectionIdCounter
            };
            return JSON.stringify(state, null, 2);
        }

        function loadState(jsonString) {
            try {
                const state = JSON.parse(jsonString);
                clearAll();
                nodeIdCounter = state.nodeIdCounter || 0;
                connectionIdCounter = state.connectionIdCounter || 0;

                state.nodes.forEach(nodeData => {
                    const newNode = createNode(nodeData.x, nodeData.y, nodeData.type);
                    newNode.id = nodeData.id; // Override generated ID
                    newNode.element.id = nodeData.id;
                    newNode.params = nodeData.params;
                    
                    if (nodeData.width && nodeData.height) {
                        newNode.element.style.width = `${nodeData.width}px`;
                        newNode.element.style.height = `${nodeData.height}px`;
                    }

                    // Restore UI values from params
                    Object.entries(nodeData.params).forEach(([paramName, value]) => {
                        const paramEl = newNode.element.querySelector(`[data-param="${paramName}"]`);
                        if(paramEl) {
                             if (paramEl.type === 'checkbox') {
                                const paramDef = NODE_DEFINITIONS[newNode.type].params.find(p=>p.name===paramName);
                                paramEl.checked = value === paramDef.labels[1];
                             } else {
                                paramEl.value = value;
                             }
                        }
                    });
                    if (newNode.type === 'text-input' && nodeData.text) {
                        newNode.text = nodeData.text;
                        newNode.element.querySelector('.node-text').value = nodeData.text;
                    }
                });
                state.connections.forEach(connData => {
                    createConnection(connData.fromNodeId, connData.toNodeId, connData.portType);
                });
                nodes.forEach(n => processNode(n.id));

            } catch (e) {
                console.error("Failed to load state:", e);
                alert("Failed to load state file. It may be corrupted.");
            }
             optionsMenu.classList.remove('show');
        }

        function saveStateToFile() {
            const jsonString = saveState();
            const blob = new Blob([jsonString], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cipher-nodes-state.json';
            a.click();
            URL.revokeObjectURL(url);
            optionsMenu.classList.remove('show');
        }

        function copyShareLink() {
            const jsonString = saveState();
            const compressed = pako.deflate(jsonString, { to: 'string' });
            const encoded = btoa(compressed).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
            const url = `${window.location.origin}${window.location.pathname}#state=${encoded}`;
            navigator.clipboard.writeText(url).then(() => {
                const originalText = copyLinkButton.innerText;
                copyLinkButton.innerText = 'Link Copied!';
                setTimeout(() => { copyLinkButton.innerText = originalText; }, 2000);
            });
            optionsMenu.classList.remove('show');
        }

        function loadStateFromUrl() {
            if (window.location.hash.startsWith('#state=')) {
                const encoded = window.location.hash.substring(7);
                try {
                    const decoded = atob(encoded.replace(/-/g, '+').replace(/_/g, '/'));
                    const jsonString = pako.inflate(decoded, { to: 'string' });
                    loadState(jsonString);
                    window.location.hash = ''; // Clear hash after loading
                } catch(e) {
                    console.error("Failed to load state from URL", e);
                    alert("Could not load shared state from URL. It may be invalid.");
                }
            }
        }


        // --- Event Listeners ---
        graphContainer.addEventListener('wheel', (e) => { e.preventDefault(); handleZoom(e.deltaY > 0 ? 'out' : 'in'); });
        zoomInButton.addEventListener('click', () => handleZoom('in'));
        zoomOutButton.addEventListener('click', () => handleZoom('out'));

        graphContainer.addEventListener('mousedown', (e) => { if (e.target !== graphContainer && e.target !== worldContainer) return; isPanning = true; });
        window.addEventListener('mousemove', (e) => { if (!isPanning) return; panX += e.movementX; panY += e.movementY; applyTransform(); });
        window.addEventListener('mouseup', () => { isPanning = false; });
        svg.addEventListener('click', (e) => { if (e.target.classList.contains('connection-line')) deleteConnection(e.target.dataset.connectionId); });
        
        addNodeButton.addEventListener('click', () => { 
            const type = nodeTypeSelect.value; 
            if (!type) return; // Don't add a node if the list is empty
            const centerX = (graphContainer.clientWidth / 2 - panX) / scale; 
            const centerY = (graphContainer.clientHeight / 2 - panY) / scale; 
            const newNode = createNode(centerX, centerY, type); 
            if (NODE_DEFINITIONS[newNode.type].group === 'Input') {
                propagateTextFromNode(newNode.id, newNode.text);
            }
        });

        optionsButton.addEventListener('click', () => {
            optionsMenu.classList.toggle('show');
        });

        hideModernToggle.addEventListener('change', (e) => {
            settings.hideModern = e.target.checked;
            populateDropdown();
        });

        clearAllButton.addEventListener('click', () => { 
            clearAll();
            createNode(25, 100, 'text-input');
        });
        
        saveStateButton.addEventListener('click', saveStateToFile);
        copyLinkButton.addEventListener('click', copyShareLink);
        loadStateButton.addEventListener('click', () => loadStateInput.click());
        loadStateInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                loadState(event.target.result);
            };
            reader.readAsText(file);
            e.target.value = ''; // Reset input so the same file can be loaded again
        });
        
        function init() {
            loadStateFromUrl(); // Check for URL state first
            if (nodes.length === 0) { // If no state loaded from URL, start fresh
                 populateDropdown();
                 createNode(25, 100, 'text-input');
                 applyTransform();
            }
        }

        // Hide the MD5 function from the global scope
        const md5_func = md5;
        md5 = undefined;
        
        init();
    </script>
</body>
</html>